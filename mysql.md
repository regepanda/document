## mysql架构
### mysql逻辑架构
1、上层架构并非mysql独有，连接处理、授权认证等
2、二层包含了mysql的大多数核心服务，如查询解析、优化、缓存以及内置函数等
3、三层包含了存储引擎
### 并发控制
1、读写锁
```
共享锁：相互不阻塞，多个用户可以同时读取同一资源
排他锁：一个写锁会阻塞其他的写锁和读锁，也就是一个用户在写入的同时其他用户是不能读或者写的
```
### 事务
1、四种隔离级别
```
未提交读：事务中的修改，即使没有提交，对其他事务是不看见的
提交读：一个事务从开始到提交之前，所做的任何修改对其他事务都是不可见的，也就是不提交不可见
可重复读：保证两个事务多次读取同样的结果是一致的
可串行化：强制事务串行执行，最高隔离级别
```
2、死锁【两个事务，一个事物执行了的写操作，锁定此行，第二个事务又尝试对此行执行写操作，会因为此行锁定发生死锁，InnoDB将最少行级排他锁的事务进行回滚解决死锁，是个不错的设计】
### 多版本并发控制
在每一行记录的后面增加两个隐藏列，记录创建版本号和删除版本号，而每一个事务在启动的时候，都有一个唯一的递增的版本号。
```
1、在插入操作时 ： 记录的创建版本号就是事务版本号。 

比如我插入一条记录, 事务id 假设是1 ，那么记录如下：也就是说，创建版本号就是事务版本号。
id　　	name　　	create version　　	delete version　　
1	     est　　  	   1
2、在更新操作的时候，采用的是先标记旧的那行记录为已删除，并且删除版本号是事务版本号，然后插入一行新的记录的方式。 

比如，针对上面那行记录，事务Id为2 要把name字段更新

update table set name= 'new_value' where id=1;

id　　　name　　	  create version　　 	delete version　　
1　　   test　　	        1	                  2　　　　　　　　
1　　 new_value　　	    2	 
 

3、删除操作的时候，就把事务版本号作为删除版本号。比如

delete from table where id=1; 

 

id　　	name　　	create   version　　	delete version　　
1	  new_value	  2	        3　　
 

 

4、查询操作： 

从上面的描述可以看到，在查询时要符合以下两个条件的记录才能被事务查询出来： 

1) 删除版本号 大于 当前事务版本号，就是说删除操作是在当前事务启动之后做的。 

2) 创建版本号 小于或者等于 当前事务版本号 ，就是说记录创建是在事务中（等于的情况）或者事务启动之前。

这样就保证了各个事务互不影响。从这里也可以体会到一种提高系统性能的思路，就是： 

通过版本号来减少锁的争用。

另外，只有read-committed和 repeatable-read 两种事务隔离级别才能使用mVcc

read-uncommited由于是读到未提交的，所以不存在版本的问题

而serializable 则会对所有读取的行加锁。
```
## Schema与数据类型优化
### 数据类型
```
(1) VARCHAR和CHAR
    a)、VARCHAR是可变的，更节省空间，但是在update时使行变得更长，产生很多碎片，当存储CHAR时，mysql会删除所有的末尾空格。
(2) ENUM
    a)、枚举类型列表中每个字符的位置其实存储的是数字，适用于一系列未来不会有太多改变的字符
    b)、每次修改其实都是在执行alter table,而且是阻塞操作
(3)、范式与反范式
    a)、范式虽然数据几乎不会存在冗余，但是表之间关联次数太多，查询效率低，反范式相反，根据具体情况选择
    b)、因为范式重复数据很少，修改时修改的数据也会减少，效率高
```
## MYSQL索引
```
(1)、索引列的顺序非常重要
    create table People (
        last_name varchar(50) not null,
        first_name varchar(50) not null, 
        dob  date  not null,
        gender  enum('m', 'f') not null,
        key(last_name,first_name,dob) /*索引*/
    );
    a)、必须按照索引的最左列查找
    b)、不能跳过索引中的列，如果有跳过，mysql只是用第一列
    c)、如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引优化查找
    
(2)、索引有效情况
    a)、全职匹配【所有索隐列都用到】
    b)、匹配最左前缀【使用索引的第一列】
    c)、匹配范围值【使用索引的第一列】
    d)、匹配列前缀【索引第一列值的前缀】
(3)、索引无效
    a)、不是按照索引的最左列开始查找
    c)、不能跳过索引中的列
    d)、如果查询中的某个列是范围查询，其右边的列都不能使用范围查询
    c)、索引列不能是表达式的一部分
(4)、myisam与innodb存储引擎的区别
    a)、myisam是非聚集索引，也就是叶子节点的data域存储的是数据记录的地址，而innodb则是存储的数据，
        为聚集索引。
    b)、在效率方面myisam的查询效率要高
```

